% Robustimizer - Copyright (c) 2024 Omid Nejadseyfi
% Licensed under the GNU General Public License v3.0, see LICENSE.md.
function [addedDes,addedNoi,maxEI]=explorExploit(Inp,optCnd,fMin,omega,globX,GlobOpData)

% This function searches for new infill DOE both on the design space and noise space
% and outputs the new infill point as well as the expected improvement of
% the onjective function value

% Input: 
% Inp        structure containing the input required for optimization
% optCnd     structure containing the settings of optimziation
% fMin       minimum value of objective function evaluated before the current step
% omega      weighting factor to balance exploration (global search) and exploitation (Local search)
% globX      optimum design evaluted before the current step


% OutPut: 
% addedDes      added infill point at design space
% addedNoi      added infill point at noise
% maxEI         maximum expected improvement
DOE=Inp.DOE;
srgModel=Inp.srgModel;
nDesVar=Inp.nDesVar;
nNoiVar=Inp.nNoiVar;
desVars=Inp.desVars;
noiDistr=Inp.noiDistr;
desRng=Inp.desRng;
noiRng=Inp.noiRng;
DOEopt=DOE(:,1:nDesVar); %Only control variable settings
gExplicit=Inp.gExplicit;
hExplicit=Inp.hExplicit;
seqMthdNum=optCnd.seqMthdNum;
LB = desRng(:,1); % Lower bound box constraints
UB = desRng(:,2); % Upper bound box constraints
optMthd=optCnd.optMthd;
[A,B,Aeq,Beq] = conLin(gExplicit,hExplicit,desVars(1:nDesVar)); % Construct linear explicit constraints
if optMthd == OptimizationMethod.InteriorPoint
                OPTIONS = optimoptions(@fmincon,'Algorithm','interior-point');
            elseif optMthd == OptimizationMethod.SQP
                OPTIONS = optimset('MaxFunEvals',2000,'Algorithm','SQP','TolFun',0.000000001,'TolX',0.000000001);
            else
                error("Unknown optimization method");
            end
            OPTIONS.Display = 'off'; % Turn off display of optimization process
H = waitbar(0,'Please wait, Finding the best infill point ... ');
    if seqMthdNum~=3
        clear glbstruct.Flag glbstruct.Noisestruct %is it necessary?
    
        %[A,B,Aeq,Beq] = conLin(gExplicit,hExplicit,desVars(1:nDesVar)); % Construct linear explicit constraints
        FirstEval=1;
        for ii = 1 : length(DOEopt(:,1)) % Perform a number of optimisations equal to the number of DOE points

            X0 = DOEopt(ii,:); % Start at all DOE points
            waitbar(ii/(length(DOEopt(:,1))),H);
            
            warning off % Suppress an annoying unimportant warning
            switch seqMthdNum 
                case 1
                    [X,Fval,exitFlagDes,lambda] = fmincon(@(designInput)GlobOpData.FuncSeqJones(designInput,Inp,optCnd,srgModel,FirstEval,fMin,omega),X0,[],[],[],[],LB,UB,[],OPTIONS);
                case 2
                    [X,Fval,exitFlagDes,lambda] = fmincon(@(designInput)GlobOpData.FuncSeqMaxS(designInput,Inp,optCnd,srgModel,FirstEval),X0,[],[],[],[],LB,UB,[],OPTIONS);
            end              
            warning off % Turn warning system on again for future warnings
            EflagDes(ii,1) = exitFlagDes;
            optDes(ii,:) = X;
            optF(ii,1) = Fval;
        end

        close(H);

        [xGlob,fGlob] = chkSortMultistart(EflagDes,optDes,optF,desRng,nDesVar);

        maxEI=-fGlob;
        addedDes=xGlob;
            
    else
        addedDes=globX;
        maxEI=[1000];
        close(H);
    end
    
    addedNoi=selectNoise(addedDes,srgModel,noiRng,nNoiVar);
    
    function addedNoi = selectNoise(addedDes,srgModel,noiRng,nNoiVar)
              
            n=3*nNoiVar; %number of start points for multi-start approach
            trialDOENoiseNormalSeq = lhsdesign(n,nNoiVar);
            trialNoise = ((trialDOENoiseNormalSeq-0.5).*repmat(6*noiDistr(:,2)',[n,1]))+repmat(noiDistr(:,1)',[n,1]);
            
            for counter = 1 : n 
                n0=trialNoise(counter,:);
                [Noi,valNoi,exitflagnoise,lambda] = fmincon(@objfun,n0,A,B,Aeq,Beq,noiRng(:,1),noiRng(:,2),[],OPTIONS,addedDes,srgModel,noiDistr);
                eFlagAll(counter,1) = exitflagnoise;
                NoiAll(counter,:) = Noi;
                valNoiAll(counter,1) = valNoi;
            end

            [addedNoi,valNoi] = chkSortMultistart(eFlagAll,NoiAll,valNoiAll,noiRng,nNoiVar);
    end
 
    function arg = objfun(n,addedDes,srgModel,noiDistr)
        EvaluationPoint=[addedDes,n];
        [ y , dy,s2_hat_Xopt]= predictor(EvaluationPoint,srgModel(1,1).dmodel);
         arg=-(s2_hat_Xopt)*prod(normpdf(n,noiDistr(:,1)',noiDistr(:,2)'),2); 

    end

end
